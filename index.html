<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Ответы на билеты — wereefy</title>
  <style>
    body{font-family:Inter,Segoe UI,Arial,Helvetica,sans-serif;margin:0;padding:24px;background:#f6f8fb;color:#0b1220}
    header{display:flex;align-items:center;justify-content:space-between}
    h1{font-size:20px;margin:0}
    .nav{margin-top:18px;display:flex;gap:8px;flex-wrap:wrap}
    .nav a{background:#fff;padding:8px 10px;border-radius:8px;text-decoration:none;color:#0b1220;border:1px solid #e3e6eb}
    .ticket{background:#fff;border-radius:10px;padding:18px;margin-top:18px;border:1px solid #e7ecf6}
    pre{background:#0f1724;color:#e6eef8;padding:12px;border-radius:8px;overflow:auto}
    code{font-family:Consolas,monaco,monospace;display:block}
    .code-line{display:block}
    .emph{color:#1b6ef6;font-weight:600}
    .speech{background:#f0f6ff;border-left:4px solid #1b6ef6;padding:10px;border-radius:6px;margin-top:10px}
    .meta{font-size:12px;color:#5b6b78}
    .disclaimer{font-size:13px;margin-top:10px;background:#fff7e6;border-left:4px solid #f59e0b;padding:12px;border-radius:6px}
    nav.fixed{/* position:sticky removed to keep nav static */}
  </style>
</head>
<body>
  <header>
    <h1>Полные ответы на билеты (тестовые варианты) — wereefy</h1>
    <div class="meta">Формат: один HTML файл · Автор: wereefy · Дата: 2025</div>
  </header>

  <div class="disclaimer">
    Этот материал предоставлен исключительно в образовательных целях для подготовки к экзамену. Это тестовые варианты и примеры ответов; автор не несёт ответственности за использование материалов в официальных экзаменационных ситуациях.
  </div>

  <nav class="nav fixed" aria-label="Навигация по билетам">
    <a href="#t1">1. Топ-2 эндпоинта</a>
    <a href="#t2">2. Резерв времени (R)</a>
    <a href="#t3">3. Сетевой граф (AoN)</a>
    <a href="#t4">4. Валидация авторизации</a>
    <a href="#t5">5. Инъекция кода (SQL)</a>
    <a href="#t6">6. SQL: средняя цена по категориям</a>
    <a href="#t7">7. Дубликаты nickname</a>
    <a href="#t8">8. Поиск свободного слота</a>
    <a href="#t9">9. Анализ уязвимости SQL</a>
    <a href="#t10">10. Товары без продаж 35 дней</a>
    <a href="#t11">11. Авторизация REST API</a>
    <a href="#t12">12. План при компрометации ключа</a>
    <a href="#t13">13. Оптимизация производительности</a>
    <a href="#t14">14. Дни недели (преобразование)</a>
    <a href="#t15">15. Тестовые сценарии регистрации</a>
    <a href="#t16">16. Валидация ФЛГ (пациент)</a>
    <a href="#t17">17. Рейтинг востребованности товара</a>
    <a href="#t18">18. Операции с множествами</a>
    <a href="#t19">19. Регex номера телефона</a>
    <a href="#t20">20. XSS: объяснение и исправление</a>
    <a href="#t21">21. Расчёт ROI</a>
    <a href="#t22">22. Сотрудники с &gt;3 задачами</a>
    <a href="#t23">23. Выбор SSL/TLS сертификата</a>
    <a href="#t24">24. Уязвимость в хешировании пароля</a>
    <a href="#t25">25. Поиск зависших сессий</a>
    <a href="#t26">26. Рекурсивное дерево директорий</a>
    <a href="#t27">27. GET запрос и курс ZWL</a>
    <a href="#t28">28. Бэкап таблицы с timestamp</a>
    <a href="#t29">29. Планирование задачи через день</a>
  </nav>

  <main>

    <section id="t1" class="ticket">
      <h2>Билет 1 — Топ-2 эндпоинта из логов (Python)</h2>
      <p>Задача: Дан список словарей (JSON) — логи веб-сервера. Вернуть два самых частых эндпоинта.</p>
      <h3>Решение (полное, пошагово)</h3>
      <p>Подход: пройти по записям, посчитать частоту каждого значения поля endpoint и вернуть два с наибольшей частотой.</p>

      <pre><code>
from collections import Counter

def top_two_endpoints(logs):
  # Функция принимает на вход 'logs' — список словарей, где каждый словарь
  # представляет запись лога веб-сервера и может содержать ключ 'endpoint'.
  # Шаг 1: извлечь все значения поля 'endpoint' из записей.
  endpoints = (entry.get('endpoint') for entry in logs if 'endpoint' in entry)
  # Шаг 2: подсчитать, сколько раз встречается каждый endpoint.
  counts = Counter(endpoints)
  # Шаг 3: вернуть список из двух наиболее частых endpoint'ов.
  return [ep for ep, _ in counts.most_common(2)]

# Пример использования (демонстрация входа и результата):
logs = [
  {"endpoint": "/api/users"},
  {"endpoint": "/api/login"},
  {"endpoint": "/api/users"},
]
print(top_two_endpoints(logs))  # Ожидаемый вывод: ['/api/users', '/api/login']
      </code></pre>

      <h4>Построчные пояснения к коду</h4>
      <ol>
        <li><strong>from collections import Counter</strong> — импортирует класс Counter, удобный для подсчёта элементов в итерируемой коллекции.</li>
        <li><strong>def top_two_endpoints(logs):</strong> — объявление функции с именем top_two_endpoints, принимающей один параметр logs.</li>
        <li><strong>endpoints = (entry.get('endpoint') for entry in logs if 'endpoint' in entry)</strong> — генераторный выражение: для каждой записи в logs пытается взять значение по ключу 'endpoint', пропуская записи без этого ключа. Генератор экономит память по сравнению со списком.</li>
        <li><strong>counts = Counter(endpoints)</strong> — создаёт объект Counter, который подсчитывает, сколько раз встречается каждое значение в endpoints.</li>
        <li><strong>return [ep for ep, _ in counts.most_common(2)]</strong> — метод most_common(2) возвращает список двух кортежей (значение, число), этот список преобразуется в список только значений endpoints для возврата.</li>
        <li><strong>logs = [...]</strong> — пример входных данных: список словарей с ключом 'endpoint'.</li>
        <li><strong>print(...)</strong> — вывод результата функции на экран для демонстрации работы кода.</li>
      </ol>

      <div class="speech">
        <strong>Ещё более подробная речь перед комиссией (построчно):</strong>
        <p>1) Мы импортируем Counter — это готовый инструмент для подсчёта частот, он удобен и эффективен. 2) Функция top_two_endpoints принимает список логов. 3) Генератор берёт поле 'endpoint' из каждой записи, это устойчиво к отсутствию ключа. 4) Counter подсчитывает вхождения каждого endpoint. 5) most_common(2) возвращает два самых частых, и мы возвращаем только сами строки адресов. 6) Пример показывает ожидаемый вход, 7) print демонстрирует ожидаемый результат. При ответе подчёркивайте, что каждая строка имеет ясную цель: импорт, объявление функции, безопасный доступ к полю, подсчёт, выбор топ-2 и демонстрация работы.</p>
      </div>

      <h4>Пояснение строк кода (пошагово, для экзаменатора и начинающего)</h4>
      <ul>
        <li><strong>from collections import Counter:</strong> импортируем готовый инструмент для подсчёта — это как таблица, где для каждого уникального адреса считается количество его появлений.</li>
        <li><strong>def top_two_endpoints(logs):</strong> объявляем функцию — переиспользуемый блок кода, принимающий список логов и возвращающий результат.</li>
        <li><strong>endpoints = (entry.get('endpoint') ...):</strong> проходим по записям и извлекаем поле 'endpoint'; если поле отсутствует — запись пропускается. Это позволяет устойчиво работать с разными форматами логов.</li>
        <li><strong>counts = Counter(endpoints):</strong> Counter аккумулирует количество вхождений для каждого адреса; реализация оптимизирована и проста в использовании.</li>
        <li><strong>counts.most_common(2):</strong> возвращает список двух наиболее частых пар (адрес, количество). Мы выбираем только адреса для финального результата.</li>
      </ul>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Уважаемая комиссия, функция top_two_endpoints решает задачу подсчёта частоты запросов в логах. Сначала мы извлекаем из каждой записи поле endpoint, затем с помощью структуры Counter считаем частоты и выбираем два наиболее частых адреса. Такой подход проходит по списку один раз и работает за O(n) по времени, где n — число записей в логе. Counter — часть стандартной библиотеки Python, что упрощает поддержку кода. При необходимости легко расширить логику фильтрацией по статусу или времени.</p>
        <p>При ответе подчеркните: 1) алгоритмическая сложность O(n), 2) использование готовых, проверенных инструментов из стандартной библиотеки, 3) возможность добавления фильтров и масштабирования (параллельная обработка или стриминг для очень больших логов).</p>
      </div>
    </section>

    <section id="t2" class="ticket">
      <h2>Билет 2 — Полный резерв времени (R)</h2>
      <p>Дано: Раннее начало (РН) = 3 дня, Позднее начало (ПН) = 4 дня, Продолжительность (t) = 22 дня.</p>
      <p>Формула полного резерва: R = ПН - РН. Здесь R = 4 - 3 = 1 день. Работа не критическая, если R &gt; 0; критическая, если R = 0.</p>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Уважаемая комиссия, полный резерв показывает, насколько можно отложить начало работы без влияния на конечный срок проекта. Рассчитывается как разница между поздним и ранним началом: R = ПН - РН = 4 - 3 = 1 день. Это означает, что задача имеет запас в один день, поэтому она не относится к критическим (критические — те, у которых резерв равен нулю). Практический вывод: задача требует внимания, но небольшая задержка не приведёт к срыву проекта. При необходимости можно рассчитать общие резервы всего графа, чтобы приоритизировать ресурсы.</p>
      </div>
      <h4>Построчное пояснение расчёта резерва</h4>
      <ol>
        <li><strong>Раннее начало (РН) = 3</strong> — минимально возможная дата начала работы;</li>
        <li><strong>Позднее начало (ПН) = 4</strong> — максимально допустимое отложение старта без сдвига завершения;</li>
        <li><strong>R = ПН - РН</strong> — вычисление полного резерва;</li>
        <li><strong>R = 1</strong> — интерпретация значения: небольшой запас в один день.</li>
      </ol>
    </section>

    <section id="t3" class="ticket">
      <h2>Билет 3 — Сетевой график (AoN)</h2>
      <p>Задача: A(4), B(5) после A, C(22) после A, D(21) после B и C.</p>
      <p>Решение: Описание связей: A → B, A → C, B → D, C → D. Критические пути и ранние/поздние сроки можно найти методом анализа сетевого графика (CPM).</p>

      <pre><code>
A(4) --> B(5)
 \
  \-> C(22)
        \-->
         D(21)
      </code></pre>

      <p>Ключ: путь A→C→D длится 4+22+21=47 дней — это самый длительный путь и он является критическим. Второй путь A→B→D длится 30 дней, поэтому имеет запас времени.</p>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Уважаемая комиссия, при построении сетевого графа каждой работе назначается длительность, а зависимости определяют последовательность выполнения. Для нашего проекта есть два возможных маршрута выполнения к завершающей работе D: через C и через B. Суммарные длительности показывают, что путь A→C→D занимает 47 дней и является критическим, то есть любые задержки на этом пути отразятся на дате завершения проекта. На практике это означает необходимый фокус управления ресурсами и рисками именно на задачах C и D. Для контроля можно рассчитывать ранние и поздние начала (ES/EF и LS/LF) и резерв каждой работы, чтобы понимать где допустимы отступления.</p>
        <p>При ответе подчеркните методы: построение графа вручную, вычисление критического пути и последующий контроль ресурсов и рисков.</p>
      </div>
      <h4>Построчные пояснения (граф и расчёты)</h4>
      <ol>
        <li><strong>A(4)</strong> — работа A длится 4 дня;</li>
        <li><strong>B(5) после A</strong> — работа B начинается после завершения A и длится 5 дней;</li>
        <li><strong>C(22) после A</strong> — работа C начинается после A и идёт 22 дня;</li>
        <li><strong>D(21) после B и C</strong> — работа D стартует после обеих предшествующих работ и длится 21 день;</li>
        <li><strong>Расчёт путей:</strong> суммируем длительности вдоль путей: A→C→D = 4+22+21 = 47; A→B→D = 4+5+21 = 30;</li>
        <li><strong>Критический путь:</strong> выбираем максимальную сумму — A→C→D.</li>
      </ol>
    </section>

    <section id="t4" class="ticket">
      <h2>Билет 4 — Валидация формы "Авторизация пользователя"</h2>
      <p>Требования: логин — кириллица/цифры/подчёркивания, 10–22 символа; email — наличие @ и домена .ru; пароль — минимум 10 символов, минимум 2 цифры и 2 заглавные буквы.</p>

      <pre><code>
import re
from typing import Tuple

# Регулярные выражения для валидации логина и email.
LOGIN_RE = re.compile(r'^[\u0400-\u04FF0-9_]{10,22}$')
EMAIL_RE = re.compile(r'^[^@\s]+@[^@\s]+\.ru$')

def validate(login: str, email: str, password: str) -> Tuple[bool, list]:
  """
  Производит валидацию трёх полей:
  - login: только кириллица, цифры и подчеркивание, длина 10-22;
  - email: базовая проверка наличия '@' и домена '.ru';
  - password: минимум 10 символов, минимум 2 цифры и 2 заглавные буквы.

  Возвращает кортеж (is_valid, errors), где errors — список ошибок.
  """
  errors = []
  # Проверка логина по регулярному выражению.
  if not LOGIN_RE.match(login):
    errors.append('Логин: только кириллица, цифры, подч., 10-22 символа')
  # Простая проверка email — для экзамена этого достаточно, в проде лучше подтверждение почты.
  if not EMAIL_RE.match(email):
    errors.append('Email: ожидается домен .ru')
  # Проверки пароля: длина, количество цифр и заглавных букв.
  if len(password) < 10:
    errors.append('Пароль слишком короткий')
  if sum(c.isdigit() for c in password) < 2:
    errors.append('Пароль — минимум 2 цифры')
  if sum(c.isupper() for c in password) < 2:
    errors.append('Пароль — минимум 2 заглавные буквы')
  # Возвращаем результат и список ошибок (можно распечатать пользователю).
  return (len(errors) == 0, errors)
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Уважаемая комиссия, данная валидация сочетает формальные проверки форматов (регулярные выражения для логина и email) и семантические проверки для пароля (минимальная длина, количество цифр и заглавных букв). Регулярные выражения позволяют задать строгий формат, но они не заменяют бизнес-валидацию и проверки на стороне сервера. Рекомендации: всегда валидировать на серверной стороне даже при наличии клиентской валидации; хранить пароли только в виде защищённых хешей (bcrypt/Argon2) и не возвращать подробные сообщения об ошибках пользователю (во избежание утечки информации о наличии учётной записи).</p>
        <p>Если комиссия спросит про улучшения — предложите двухфакторную аутентификацию, капчу против брутфорса и лимиты попыток входа.</p>
      </div>
      <h4>Построчные пояснения к коду валидации</h4>
      <ol>
        <li><strong>import re</strong> — модуль с поддержкой регулярных выражений;</li>
        <li><strong>LOGIN_RE = ...</strong> — шаблон для логина, ограничивает символы и длину;</li>
        <li><strong>EMAIL_RE = ...</strong> — базовый шаблон email с доменом .ru;</li>
        <li><strong>def validate(...)</strong> — функция-обёртка для всех проверок;</li>
        <li><strong>errors = []</strong> — собираем сообщения об ошибках для удобного отображения;</li>
        <li><strong>if not LOGIN_RE.match(login):</strong> — если логин не соответствует шаблону, добавляем ошибку;</li>
        <li><strong>sum(c.isdigit() for c in password)</strong> — подсчёт цифр в пароле;</li>
        <li><strong>sum(c.isupper() for c in password)</strong> — подсчёт заглавных букв в пароле;</li>
        <li><strong>return (len(errors) == 0, errors)</strong> — возвращаем результат и список ошибок.</li>
      </ol>
    </section>

    <section id="t5" class="ticket">
      <h2>Билет 5 — Инъекция кода (пример и исправление)</h2>
      <p>Инъекция кода — когда пользовательские данные интерпретируются как часть исполняемого кода или запроса.</p>

      <pre><code>
# Уязвимая версия (SQL-инъекция):
def get_user(cursor, user_input):
    query = f"SELECT * FROM users WHERE name = '{user_input}'"
    cursor.execute(query)

# Безопасная версия (параметризованный запрос):
def get_user_safe(cursor, user_input):
    query = "SELECT * FROM users WHERE name = %s"
    cursor.execute(query, (user_input,))
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Уважаемая комиссия, инъекционные атаки происходят, когда данные пользователя интерпретируются как код. В случае SQL это позволяет изменить структуру запросов и получить несанкционированный доступ. Лучшая практика — использовать параметризованные запросы/подготовленные выражения, которые передают данные отдельно от тела SQL. Также рекомендую: минимизировать привилегии у учётных записей БД, логировать подозрительные попытки и использовать ORM, где это возможно. Поясните на примере: если вставить "' OR '1'='1" в уязвимый код — можно получить все записи; параметризация делает это невозможным.</p>
      </div>
      <h4>Построчные пояснения к примерам SQL-инъекции</h4>
      <ol>
        <li><strong>def get_user(cursor, user_input):</strong> — функция демонстрирует уязвимый подход: подстановка значения пользователя в строку запроса;</li>
        <li><strong>query = f"SELECT ..."</strong> — строковая интерполяция опасна, если вход не контролируется;</li>
        <li><strong>cursor.execute(query)</strong> — выполнение уязвимого запроса;</li>
        <li><strong>def get_user_safe(...)</strong> — безопасный вариант: подготовленный запрос и отдельная передача параметров;</li>
        <li><strong>cursor.execute(query, (user_input,))</strong> — драйвер сам экранирует параметры, предотвращая инъекции.</li>
      </ol>
    </section>

    <section id="t6" class="ticket">
      <h2>Билет 6 — SQL: средняя цена по категориям выше 5000</h2>
      <pre><code>
    -- Возвращает название категории и среднюю цену товаров в ней.
    -- Использует JOIN по category_id, затем группирует и фильтрует по средней цене.
    SELECT c.name AS category, AVG(t.price) AS avg_price
    FROM Tovar t
    JOIN Category c ON c.id = t.category_id
    GROUP BY c.name
    HAVING AVG(t.price) > 5000
    ORDER BY avg_price ASC;
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Запрос выполняет JOIN с таблицей категорий для получения имени категории, затем группирует товары по категории и вычисляет среднюю цену. HAVING применяется для фильтрации групп по агрегированному значению. Это стандартная аналитическая конструкция SQL: JOIN + GROUP BY + HAVING. При представлении стоит указать, что в больших БД важно проверить индексы на полях, используемых в JOIN и WHERE, чтобы запрос выполнялся быстро.</p>
      </div>
      <h4>Построчные пояснения SQL-запроса</h4>
      <ol>
        <li><strong>SELECT c.name AS category, AVG(t.price) AS avg_price</strong> — выбираем имя категории и среднюю цену;</li>
        <li><strong>FROM Tovar t</strong> — основная таблица товаров;</li>
        <li><strong>JOIN Category c ON c.id = t.category_id</strong> — подсоединяем таблицу категорий для получения названия;</li>
        <li><strong>GROUP BY c.name</strong> — сгруппировать результаты по категориям;</li>
        <li><strong>HAVING AVG(t.price) > 5000</strong> — отфильтровать категории с средней ценой выше 5000;</li>
        <li><strong>ORDER BY avg_price ASC</strong> — сортируем по возрастанию средней цены.</li>
      </ol>
    </section>

    <section id="t7" class="ticket">
      <h2>Билет 7 — Дубликаты по nickname и удаление</h2>
      <p>Поиск дубликатов:</p>
      <pre><code>
    -- Находит никнеймы, встречающиеся более одного раза, и их количество.
    SELECT nickname, COUNT(*) AS cnt
    FROM Users
    GROUP BY nickname
    HAVING COUNT(*) > 1;
      </code></pre>
      <p>Удалить дубликаты, оставив минимальный id:</p>
      <pre><code>
-- Удаляет дубликаты, оставляя запись с минимальным id для каждого nickname.
DELETE FROM Users
WHERE id NOT IN (
  SELECT MIN(id) FROM Users GROUP BY nickname
);
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Первый запрос использует GROUP BY и HAVING для обнаружения повторов — это стандартный приём. Удаление дубликатов реализовано через подзапрос, оставляющий минимальный id для каждой группы. Важно отметить: перед удалением нужно создать резервную копию и убедиться в отсутствии внешних зависимостей (foreign keys). В реальной практике часто сначала объединяют данные дублей (например, суммируют покупки), затем удаляют лишние записи.</p>
      </div>
      <h4>Построчные пояснения SQL-операций по дубликатам</h4>
      <ol>
        <li><strong>SELECT nickname, COUNT(*) AS cnt FROM Users GROUP BY nickname HAVING COUNT(*) > 1;</strong> — агрегируем по nickname и выбираем только те, где больше одной записи;</li>
        <li><strong>DELETE FROM Users WHERE id NOT IN (SELECT MIN(id) FROM Users GROUP BY nickname);</strong> — удаляем все записи, кроме одной (с минимальным id) для каждого nickname.</li>
      </ol>
    </section>

    <section id="t8" class="ticket">
      <h2>Билет 8 — Поиск свободного временного интервала</h2>
      <p>Даны интервалы работы: [(08:30,13:00),(14:00,17:00),(17:30,20:00)]. Найти первый доступный слот длины value_minutes.</p>
      <pre><code>
    from datetime import datetime, timedelta

    def find_slot(schedule, value_minutes):
      """
      Ищет первый свободный временной слот заданной длительности.
      schedule: список кортежей (start_str, end_str) в формате '%H:%M'.
      value_minutes: длительность искомого слота в минутах.
      Возвращает кортеж (start, end) в строковом формате или None, если слота нет.
      """
      fmt = '%H:%M'
      # Конвертация строк в datetime для корректных арифметических операций.
      slots = [(datetime.strptime(a,fmt), datetime.strptime(b,fmt)) for a,b in schedule]
      # Проходим по соседним парам интервалов и ищем промежуток между ними.
      for i in range(len(slots)-1):
        end_current = slots[i][1]
        start_next = slots[i+1][0]
        # Если разница между концом текущего и началом следующего больше или равна нужной длительности — возвращаем слот.
        if (start_next - end_current).total_seconds() >= value_minutes*60:
          return end_current.strftime(fmt), (end_current + timedelta(minutes=value_minutes)).strftime(fmt)
      return None

    schedule = [("08:30","13:00"),("14:00","17:00"),("17:30","20:00")]
    print(find_slot(schedule, 30))  # Пример: ('13:00','13:30') если между 13:00 и 14:00 есть пауза
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Алгоритм переводит строки времени в объекты datetime для корректного сравнения, затем проверяет промежутки между последовательными рабочими интервалами и возвращает первый подходящий слот требуемой длительности. Этот подход прост и надёжен для статического расписания; для динамического расписания пригодятся структуры данных для эффективной вставки и поиска свободных интервалов (например, дерево интервалов).</p>
      </div>
      <h4>Построчные пояснения к функции поиска слота</h4>
      <ol>
        <li><strong>from datetime import ...</strong> — импорт для работы с временем;</li>
        <li><strong>def find_slot(...)</strong> — объявление функции с описанием аргументов;</li>
        <li><strong>fmt = '%H:%M'</strong> — формат времени для парсинга строк;</li>
        <li><strong>slots = [...]</strong> — парсинг входных строк в datetime объекты;</li>
        <li><strong>for i in range(...)</strong> — проверка каждого соседнего промежутка;</li>
        <li><strong>if (start_next - end_current).total_seconds() >= value_minutes*60</strong> — сравнение интервала с требуемой длительностью;</li>
        <li><strong>return ...</strong> — возвращаем найденный слот в строковом формате.</li>
      </ol>
    </section>

    <section id="t9" class="ticket">
      <h2>Билет 9 — Анализ уязвимого фрагмента</h2>
      <pre><code>
user_id_input = input("Введите ID пользователя: ")
query = f"SELECT * FROM usid WHERE id = {user_id_input}"
cursor.execute(query)
      </code></pre>
      <p>Проблема: SQL-инъекция. Исправление — параметризованный запрос и проверка типа:</p>
      <pre><code>
try:
    uid = int(user_id_input)
except ValueError:
    raise ValueError('Неверный ID')
cursor.execute("SELECT * FROM usid WHERE id = %s", (uid,))
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Проблема в исходном фрагменте — прямое включение пользовательского ввода в SQL. Я решаю её в два шага: сначала пытаюсь явно привести ввод к целочисленному типу, чтобы гарантировать соответствие ожидаемому формату; затем использую параметризованный запрос, где драйвер БД сам экранирует параметры. Кроме того, рекомендую логировать неудачные попытки и ограничивать повторные запросы, чтобы выявлять автоматические атаки.</p>
      </div>
      <h4>Построчные пояснения к исправлению уязвимости</h4>
      <ol>
        <li><strong>user_id_input = input(...)</strong> — получение строки от пользователя;</li>
        <li><strong>uid = int(user_id_input)</strong> — попытка привести ввод к целому числу; если не получается — вход некорректен;</li>
        <li><strong>cursor.execute("SELECT ...", (uid,))</strong> — параметризация запроса, безопасная передача параметра в БД.</li>
      </ol>
    </section>

    <section id="t10" class="ticket">
      <h2>Билет 10 — Товары без продаж 35 дней</h2>
      <pre><code>
    -- Находим товары, по которым не было продаж в течение последних 35 дней.
    SELECT p.tovar_id
    FROM Prodagi p
    GROUP BY p.tovar_id
    HAVING MAX(p.sale_date) < CURRENT_DATE - INTERVAL '35 days'
    ;
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Запрос группирует продажи по товару и находит последнюю дату продажи (MAX). Затем сравнивает её с текущей датой минус 35 дней. Если последняя продажа старее этого порога, товар можно рассматривать как неактивный. На практике дополнительно учитывают запасы на складе, сезонность и маркетинговые активности перед окончательным решением о снятии товара с продажи.</p>
      </div>
      <h4>Построчные пояснения SQL-запроса</h4>
      <ol>
        <li><strong>SELECT p.tovar_id FROM Prodagi p</strong> — выбрать идентификатор товара из таблицы продаж;</li>
        <li><strong>GROUP BY p.tovar_id</strong> — группировать записи по товару;</li>
        <li><strong>HAVING MAX(p.sale_date) &lt; CURRENT_DATE - INTERVAL '35 days'</strong> — оставить только те товары, у которых максимальная дата продажи старее 35 дней;</li>
      </ol>
    </section>

    <section id="t11" class="ticket">
      <h2>Билет 11 — Авторизация для REST API</h2>
      <p>Проблема: эндпоинт возвращает любой заказ без проверки прав.</p>
      <pre><code>
# Пример на Flask + JWT проверка
from flask import Flask, request, jsonify
import jwt

app = Flask(__name__)

def get_user_from_token(token):
    payload = jwt.decode(token, 'secret', algorithms=['HS256'])
    return payload.get('user_id')

@app.route('/api/sales/orders/<int:order_number>')
def get_order(order_number):
    auth = request.headers.get('Authorization')
    if not auth:
        return jsonify({'error':'no auth'}), 401
    token = auth.split()[-1]
    user_id = get_user_from_token(token)
    order = db.get_order(order_number)
    if order.user_id != user_id and not user_has_role(user_id,'admin'):
        return jsonify({'error':'forbidden'}), 403
    return jsonify(order.to_dict())
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Для исправления уязвимости добавлена аутентификация и проверка прав доступа: запросы должны иметь действительный токен JWT, сервер декодирует его и извлекает идентификатор пользователя. После этого проверяется, принадлежит ли заказ текущему пользователю или у пользователя есть роль администратора. Если ни одно условие не выполняется — возвращается 403. Кроме технического решения, важно отметить использование HTTPS, сроков действия токенов, механизма отзыва токенов и логирования доступа к ресурсам.</p>
      </div>
      <h4>Построчные пояснения к коду авторизации (Flask + JWT)</h4>
      <ol>
        <li><strong>from flask ...</strong> — импортируем инструменты веб-фреймворка Flask;</li>
        <li><strong>import jwt</strong> — библиотека для работы с JSON Web Tokens;</li>
        <li><strong>def get_user_from_token(token):</strong> — функция декодирования токена и извлечения user_id;</li>
        <li><strong>auth = request.headers.get('Authorization')</strong> — получение заголовка авторизации из запроса;</li>
        <li><strong>token = auth.split()[-1]</strong> — выделяем сам токен (Bearer ...);</li>
        <li><strong>order = db.get_order(order_number)</strong> — извлекаем заказ из БД по номеру;</li>
        <li><strong>if order.user_id != user_id and not user_has_role(...)</strong> — проверка прав доступа: владелец или администратор;</li>
      </ol>
    </section>

    <section id="t12" class="ticket">
      <h2>Билет 12 — План действий при компрометации закрытого ключа</h2>
      <ol>
        <li>Изолировать сервер и прекратить использование ключа.</li>
        <li>Сгенерировать новый ключ и новый CSR, получить новый сертификат.</li>
        <li>Обновить серверы и клиентские конфигурации.</li>
        <li>Отозвать старый сертификат через CRL или OCSP.</li>
        <li>Проинформировать пользователей и аудитировать логи.</li>
      </ol>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>План действий при компрометации ключа должен быть быстрым и последовательным: немедленная изоляция и прекращение использования ключа, генерация нового ключа и получение нового сертификата, развёртывание нового сертификата на всех серверах, отзыв старого сертификата через CRL/OCSP и уведомление заинтересованных сторон. Важны также аудит логов и анализ причин компрометации — куда был получен доступ, какие данные могли быть скомпрометированы. OCSP предоставляет возможность онлайн-проверки статуса, CRL — это периодический список отозванных сертификатов; выбирают механизм в зависимости от архитектуры и требований к задержке проверки.</p>
      </div>
      <h4>Построчные пояснения плана действий</h4>
      <ol>
        <li><strong>Изолировать сервер</strong> — прекратить использование ключа и отключить сервисы, если требуется;</li>
        <li><strong>Сгенерировать новый ключ и CSR</strong> — подготовить запрос на выдачу нового сертификата;</li>
        <li><strong>Обновить серверы</strong> — заменить сертификат и ключ на всех инстансах;</li>
        <li><strong>Отозвать старый сертификат</strong> — через CRL/OCSP;</li>
        <li><strong>Проинформировать пользователей</strong> — в зависимости от степени инцидента и политики уведомлений.</li>
      </ol>
    </section>

    <section id="t13" class="ticket">
      <h2>Билет 13 — Оптимизация производительности</h2>
      <p>Проблемы и два решения для каждой:</p>
      <ul>
        <li><strong>Множество мелких HTTP-запросов:</strong> объединение (bundling), использование HTTP/2 или серверного рендеринга.</li>
        <li><strong>Долгие запросы к БД:</strong> индексы и оптимизация запросов, денормализация/материализованные представления.</li>
        <li><strong>Отсутствие кэширования:</strong> CDN + кеш браузера, кеш на уровне приложений (Redis) для часто запрашиваемых данных.</li>
      </ul>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Для фронтенда рекомендую объединять и минимизировать скрипты и стили, использовать HTTP/2 или HTTP/3 для уменьшения накладных расходов на соединения и серверный рендеринг при необходимости. Для бэкенда — анализировать slow-query, добавлять индексы по фильтруемым полям и использовать материализованные представления для тяжёлых агрегатов. Для кэширования — CDN для статических ресурсов и Redis/Memcached для результатов тяжёлых запросов. Также подчеркните важность мониторинга (APM), чтобы подтверждать эффект от оптимизаций.</p>
      </div>
      <h4>Построчные пояснения рекомендаций по оптимизации</h4>
      <ol>
        <li><strong>Объединение и минификация</strong> — уменьшают количество и размер ресурсов, загружаемых браузером;</li>
        <li><strong>HTTP/2</strong> — уменьшает накладные расходы и ускоряет загрузку за счёт мультиплексирования;</li>
        <li><strong>Индексы</strong> — ускоряют поиск данных на стороне БД;</li>
        <li><strong>Материализованные представления</strong> — сохраняют результат тяжёлых агрегаций для быстрого чтения;</li>
        <li><strong>CDN и Redis</strong> — снижают нагрузку и улучшают отклик путем кеширования как статики, так и динамических результатов.</li>
      </ol>
    </section>

    <section id="t14" class="ticket">
      <h2>Билет 14 — Преобразование дня недели</h2>
      <pre><code>
def day_to_num(day: str) -> int:
    days = ['понедельник','вторник','среда','четверг','пятница','суббота','воскресенье']
    day = day.lower()
    if day not in days:
        raise ValueError('Неверный день')
    return days.index(day)

def num_to_day(n: int) -> str:
    days = ['понедельник','вторник','среда','четверг','пятница','суббота','воскресенье']
    if not 0 <= n <= 6:
        raise ValueError('Номер вне диапазона')
    return days[n]
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Функции реализуют явное преобразование между названием дня и его числовым представлением с проверкой корректности входных данных. Это предохраняет программу от некорректного ввода и делает поведение предсказуемым. Отвечая, отметьте, что любая функция, принимающая внешний ввод, должна проверять диапазон и формат и возвращать понятные ошибки.</p>
      </div>
      <h4>Построчные пояснения к функциям дня недели</h4>
      <ol>
        <li><strong>days = [...]</strong> — явный список названий дней, используемый как справочник;</li>
        <li><strong>day = day.lower()</strong> — нормализация ввода для нечувствительного к регистру сравнения;</li>
        <li><strong>if day not in days</strong> — проверка корректности строки;</li>
        <li><strong>return days.index(day)</strong> — возвращает индекс дня (0–6);</li>
        <li><strong>num_to_day</strong> — обратная операция: проверка диапазона и возврат строки по индексу.</li>
      </ol>
    </section>

    <section id="t15" class="ticket">
      <h2>Билет 15 — Тестовые сценарии для формы регистрации</h2>
      <p>Включаю 5 позитивных и 5 негативных кейсов (описание в тексте).</p>
      <ul>
        <li><strong>Позитивные:</strong> валидный логин/email/пароль; минимальная длина пароля; максимально допустимый логин; пароль с 2 цифрами и 2 заглавными; email с поддоменом.</li>
        <li><strong>Негативные:</strong> логин короче 10; логин с латиницей; email без .ru; пароль короче 10; пароль с менее чем 2 цифрами.</li>
      </ul>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>При тестировании формы регистрации важно покрыть позитивные сценарии (валидные данные, граничные значения) и негативные (повторяющиеся логины, некорректные форматы, атаки на ввод). Это обеспечивает надёжность системы и защищает от регрессий при дальнейшем развитии. Рекомендую автоматизировать эти тесты и прогонять их при каждом изменении кода (CI).</p>
      </div>
      <h4>Построчные пояснения к тест-кейсам</h4>
      <ol>
        <li><strong>Позитивные кейсы</strong> — описывают корректное поведение системы при валидных данных и граничных значениях;</li>
        <li><strong>Негативные кейсы</strong> — проверяют, что система корректно реагирует на некорректный ввод и не допускает уязвимостей;</li>
        <li><strong>Ожидаемые результаты</strong> — для каждого кейса нужно указать конкретное ожидаемое поведение (ошибка, сообщение, успешный вход и т.д.).</li>
      </ol>
    </section>

    <section id="t16" class="ticket">
      <h2>Билет 16 — Валидация для регистрации пациента на ФЛГ</h2>
      <pre><code>
import re
from datetime import date

NAME_RE = re.compile(r'^[\u0400-\u04FF ]+$')

def validate_patient(fio, dob, polis, last_flg_date, dose):
    errors = []
    if not NAME_RE.match(fio):
        errors.append('ФИО: только кириллица и пробелы')
    dob_date = date.fromisoformat(dob)
    if dob_date >= date.today():
        errors.append('Некорректная дата рождения')
    if len(polis) != 12 or not polis.isdigit():
        errors.append('Номер полиса неверного формата')
    last = date.fromisoformat(last_flg_date)
    if (date.today() - last).days &lt; 365:
        errors.append('Флюорография была меньше года назад')
    if not (0.6 <= float(dose) <= 0.8):
        errors.append('Доза вне допустимого диапазона')
    return errors
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Валидация медицинских данных требует строгого соблюдения форматов и регламентов. Функция проверяет ФИО на кириллицу, предотвращая ввод некорректных символов, проверяет дату рождения и возраст, формат номера полиса и дату последней флюорографии, а также диапазон дозы облучения. При реальном внедрении дополнительно нужно учитывать хранение согласий пациента и соответствовать требованиям по защите персональных данных.</p>
      </div>
      <h4>Построчные пояснения к функции validate_patient</h4>
      <ol>
        <li><strong>NAME_RE</strong> — шаблон для проверки ФИО на кириллицу и пробелы;</li>
        <li><strong>dob_date = date.fromisoformat(dob)</strong> — преобразование строки в дату;</li>
        <li><strong>if dob_date >= date.today()</strong> — проверка, что дата рождения не в будущем;</li>
        <li><strong>len(polis) != 12 or not polis.isdigit()</strong> — валидация формата номера полиса;</li>
        <li><strong>if (date.today() - last).days &lt; 365</strong> — проверка, что последняя флюорография была не менее года назад;</li>
        <li><strong>if not (0.6 <= float(dose) <= 0.8)</strong> — проверка дозы облучения в допустимом диапазоне.</li>
      </ol>
    </section>

    <section id="t17" class="ticket">
      <h2>Билет 17 — Рейтинг востребованности товара</h2>
      <pre><code>
-- Рассчитывает рейтинг востребованности товара за последнюю неделю:
-- продажи / просмотры; защищается от деления на ноль.
SELECT
  p.prod_id,
  CASE WHEN SUM(v.views) = 0 THEN 0
       ELSE SUM(p.amount_sold)::float / SUM(v.views)
  END AS rating
FROM Prodagi p
LEFT JOIN Views v ON v.prod_id = p.prod_id AND v.view_date >= CURRENT_DATE - INTERVAL '7 days'
WHERE p.sale_date >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY p.prod_id;
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Рейтинг рассчитывается как отношение суммарного количества проданных единиц к числу просмотров за тот же период. Чтобы избежать деления на ноль, используется CASE, возвращающий 0 при отсутствии просмотров. При обсуждении упомяните возможную нормализацию и сглаживание (moving average), чтобы уменьшить влияние всплесков продаж или просмотров.</p>
      </div>
      <h4>Построчные пояснения SQL для рейтинга товара</h4>
      <ol>
        <li><strong>LEFT JOIN Views v ...</strong> — соединяем таблицу просмотров по prod_id и дате за последнюю неделю;</li>
        <li><strong>SUM(p.amount_sold)</strong> — суммарное количество проданных единиц за период;</li>
        <li><strong>SUM(v.views)</strong> — суммарное количество просмотров за период;</li>
        <li><strong>CASE WHEN SUM(v.views) = 0 THEN 0</strong> — обработка деления на ноль;</li>
        <li><strong>GROUP BY p.prod_id</strong> — агрегирование по товару.</li>
      </ol>
    </section>

    <section id="t18" class="ticket">
      <h2>Билет 18 — Операции с множествами</h2>
      <pre><code>
    list_a = [10,20,30,40,50]
    list_b = [40,50,60,70,80]
    # Преобразуем списки в множества — это удаляет дубли и позволяет эффективно выполнять операции множеств.
    set_a = set(list_a)
    set_b = set(list_b)
    # Пересечение — общие элементы
    common = set_a & set_b
    # Разность — элементы, уникальные для первого списка
    unique_a = set_a - set_b
    # Объединение — все уникальные элементы из обоих списков
    all_unique = set_a | set_b
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Множества предоставляют эффективные операции над коллекциями: пересечение для общих элементов, разность для уникальных элементов первого списка и объединение для всех уникальных значений. Это реализуется быстро и ясно в Python и подходит для задач анализа данных и фильтрации.</p>
      </div>
      <h4>Построчное пояснение операций с множествами</h4>
      <ol>
        <li><strong>set_a = set(list_a)</strong> — создание множества из списка, убирает дубли;</li>
        <li><strong>common = set_a & set_b</strong> — пересечение множеств: элементы, присутствующие в обоих списках;</li>
        <li><strong>unique_a = set_a - set_b</strong> — элементы, которые есть только в первом списке;</li>
        <li><strong>all_unique = set_a | set_b</strong> — объединение — все уникальные элементы из двух коллекций.</li>
      </ol>
    </section>

    <section id="t19" class="ticket">
      <h2>Билет 19 — Регулярное выражение для номера телефона</h2>
      <pre><code>
import re
# Регулярное выражение покрывает форматы: +7XXXXXXXXXX, 8XXXXXXXXXX, +7 (XXX) XXX-XX-XX
PAT = re.compile(r'^(?:\+7\d{10}|8\d{10}|\+7 \(\d{3}\) \d{3}-\d{2}-\d{2})$')
def valid_phone(s):
    # Возвращает True, если строка соответствует ожидаемому формату номера
    return bool(PAT.match(s))
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Регулярное выражение покрывает запрошенные форматы. На практике сначала нормализуют вход (удаляют пробелы, дефисы, скобки), затем проверяют по единому шаблону и при необходимости приводят к международному формату (E.164). Это упрощает хранение и сравнение номеров.</p>
      </div>
      <h4>Построчные пояснения к регулярному выражению</h4>
      <ol>
        <li><strong>\+7\d{10}</strong> — формат +7 и ровно 10 цифр;</li>
        <li><strong>8\d{10}</strong> — альтернативный формат с префиксом 8;</li>
        <li><strong>\+7 \(\d{3}\) ...</strong> — формат с пробелами и скобками по маске +7 (XXX) XXX-XX-XX;</li>
        <li><strong>Проверка</strong> — PAT.match(s) вернёт совпадение, если строка строго соответствует одному из форматов.</li>
      </ol>
    </section>

    <section id="t20" class="ticket">
      <h2>Билет 20 — Межсайтовый скриптинг (XSS)</h2>
      <p>XSS — когда злоумышленник вставляет скрипт в страницу, который затем выполняется в браузере других пользователей.</p>
      <pre><code>
<!-- Уязвимая версия -->
&lt;div&gt;Комментарий: &lt;span&gt;{user_comment}&lt;/span&gt;&lt;/div&gt;

<!-- Безопасная версия (экранирование) -->
&lt;div&gt;Комментарий: &lt;span&gt;&lt;!-- эскейп(user_comment) --&gt;&lt;/span&gt;&lt;/div&gt;
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>XSS — распространённая уязвимость. Основные меры защиты: строгая фильтрация или экранирование пользовательского ввода при выводе в HTML, Content Security Policy для ограничения источников скриптов, и использование шаблонизаторов, которые по умолчанию экранируют вывод. В дополнение, стоит логировать подозрительные вводы и проводить автоматические сканирования безопасности приложений.</p>
      </div>
      <h4>Построчные пояснения к примерам XSS</h4>
      <ol>
        <li><strong>&lt;span&gt;{user_comment}&lt;/span&gt;</strong> — уязвимый вывод без экранирования, который может выполнить JS-код;</li>
        <li><strong>экранирование</strong> — заменяем специальные символы перед вставкой в HTML, чтобы они выводились как текст, а не исполнялись;</li>
        <li><strong>CSP</strong> — политику контента можно добавить в заголовки для ограничения исполнения скриптов и источников.</li>
      </ol>
    </section>

    <section id="t21" class="ticket">
      <h2>Билет 21 — Расчёт ROI</h2>
      <p>Затраты: 2 200 000 руб. Ежегодная экономия: 800 000 руб/год? (в задаче написано ежегодная и ежемесячная — предполагаю ежегодная экономия 800 000), рост доходов 350 000 в год, срок 4 года.</p>
      <pre><code>
TotalBenefit = (800000 + 350000) * 4 = 4,600,000
ROI = (TotalBenefit - Cost) / Cost = (4,600,000 - 2,200,000)/2,200,000 ≈ 1.09 => 109%
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>ROI = (выгода - затраты) / затраты. При заданных предпосылках общая выгода за 4 года составляет (800k + 350k) * 4 = 4.6M, чистая выгода 2.4M, ROI ≈ 109%. При ответе укажите допущения: экономия указана как годовая; в реальной оценке стоит учесть дисконтирование денежных потоков и возможные операционные расходы.</p>
      </div>
      <h4>Построчные пояснения к вычислению ROI</h4>
      <ol>
        <li><strong>TotalBenefit = (800000 + 350000) * 4</strong> — складываем ежегодную экономию и рост доходов, умножаем на срок в годах;</li>
        <li><strong>ROI = (TotalBenefit - Cost) / Cost</strong> — отношение чистой выгоды к затратам;</li>
        <li><strong>109%</strong> — интерпретация: проект окупается и приносит прибыль за указанный период при предъявленных допущениях.</li>
      </ol>
    </section>

    <section id="t22" class="ticket">
      <h2>Билет 22 — Сотрудники с более чем 3 активными задачами</h2>
      <pre><code>
SELECT s.id, s.name, COUNT(t.id) AS active_tasks
FROM Sotrudniki s
JOIN Tasks t ON t.sotrudnik_id = s.id
WHERE t.status = 'active'
GROUP BY s.id, s.name
HAVING COUNT(t.id) &gt; 3;
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Запрос подсчитывает количество активных задач для каждого сотрудника и фильтрует тех, у кого их больше трёх. Такой отчёт полезен для балансировки нагрузки и менеджмента задач. При обсуждении отметьте возможные расширения: вывод списка задач, временных меток и приоритета для принятия решений.</p>
      </div>
      <h4>Построчные пояснения к SQL-запросу</h4>
      <ol>
        <li><strong>SELECT s.id, s.name, COUNT(t.id) AS active_tasks</strong> — выбираем id и имя сотрудника и считаем связанные задачи;</li>
        <li><strong>JOIN Tasks t ON ...</strong> — связываем таблицы по идентификатору сотрудника;</li>
        <li><strong>WHERE t.status = 'active'</strong> — учитываем только активные задачи;</li>
        <li><strong>GROUP BY s.id, s.name</strong> — группируем по сотруднику;</li>
        <li><strong>HAVING COUNT(t.id) &gt; 3</strong> — фильтруем сотрудников с более чем тремя активными задачами.</li>
      </ol>
    </section>

    <section id="t23" class="ticket">
      <h2>Билет 23 — Выбор типа SSL/TLS сертификата</h2>
      <p>Рекомендация: Multi-Domain (SAN) сертификат или Wildcard? Для домена и поддоменов лучше Multi-Domain/SAN или Wildcard. Если поддоменов немного и фиксированы — Multi-Domain; если много динамических — Wildcard.</p>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Я рекомендую Multi-Domain/SAN сертификат для конкретных заранее известных имён: он даёт явный список защищённых доменов и удобство управления. Wildcard удобен при большом количестве динамических поддоменов, но несёт риски централизованного использования одного ключа. При ответе объясните преимущества/недостатки каждого варианта и предложите процесс ротации ключей и защиты приватного ключа.</p>
      </div>
      <h4>Построчные пояснения по выбору сертификата</h4>
      <ol>
        <li><strong>Wildcard</strong> — покрывает все поддомены одного уровня (например, *.shar-contora.com), удобно, но несёт риск при компрометации ключа;</li>
        <li><strong>Multi-Domain/SAN</strong> — явно перечисляет защищаемые имена, лучше контроль и аудит;</li>
        <li><strong>Выбор</strong> — для фиксированного набора поддоменов предпочту Multi-Domain; для динамического множества — Wildcard.</li>
      </ol>
    </section>

    <section id="t24" class="ticket">
      <h2>Билет 24 — Уязвимость в check_password</h2>
      <pre><code>
    def check_password(input_pass, stored_hash):
        # Пример с hashlib приведён в образовательных целях.
        # В реальной системе используйте bcrypt или Argon2 с солью.
        import hashlib, hmac
        # Хешируем введённый пароль (для демонстрации) — в продакшене используйте адаптивные алгоритмы.
        hashed = hashlib.sha256(input_pass.encode()).hexdigest()
        # Безопасное сравнение хешей для защиты от атак по времени.
        return hmac.compare_digest(hashed, stored_hash)
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Встроенная функция hash() непредсказуема и небезопасна для паролей. Рекомендуется bcrypt или Argon2 с солью и адаптивной сложностью. Для сравнения хешей используйте hmac.compare_digest, чтобы избежать атак по времени. Также обсудите стратегию миграции старых хешей и периодическое обновление алгоритма.</p>
      </div>
      <h4>Построчные пояснения к check_password</h4>
      <ol>
        <li><strong>input_pass</strong> — строка пароля, введённая пользователем;</li>
        <li><strong>stored_hash</strong> — ранее сохранённый хеш пароля;</li>
        <li><strong>hashlib.sha256(...)</strong> — демонстрационный способ получения хеша (не рекомендуется для паролей в проде);</li>
        <li><strong>hmac.compare_digest</strong> — безопасное сравнение двух строк, устойчивое к тайминг-атакам.</li>
      </ol>
    </section>

    <section id="t25" class="ticket">
      <h2>Билет 25 — Поиск зависших сессий</h2>
      <pre><code>
SELECT * FROM USessions
WHERE session_status != 'finished'
  AND last_activ &lt; NOW() - INTERVAL '20 minutes';
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Запрос определяет сессии, которые не имеют статус завершённой и давно не обновлялись. Такие сессии могут указывать на проблемы на клиенте или попытки злоупотребления. В рабочей системе стоит автоматически завершать подобные сессии или отправлять оповещения, а также обеспечить аудит и метрики по их частоте.</p>
      </div>
      <h4>Построчные пояснения к запросу зависших сессий</h4>
      <ol>
        <li><strong>SELECT * FROM USessions</strong> — получаем данные всех сессий;</li>
        <li><strong>WHERE session_status != 'finished'</strong> — исключаем завершённые сессии;</li>
        <li><strong>AND last_activ &lt; NOW() - INTERVAL '20 minutes'</strong> — выбираем те, у которых последнее действие было более 20 минут назад.</li>
      </ol>
    </section>

    <section id="t26" class="ticket">
      <h2>Билет 26 — Рекурсивное дерево каталога</h2>
        <pre><code>
    import os

    def tree(path, prefix=''):
      """
      Рекурсивно печатает дерево директорий, аналогично утилите tree.
      Обрабатывает ошибки доступа и форматирует вывод.
      """
      try:
        entries = sorted(os.listdir(path))
      except PermissionError:
        print(prefix + '[permission denied]')
        return
      for i, name in enumerate(entries):
        full = os.path.join(path, name)
        connector = '└── ' if i == len(entries)-1 else '├── '
        print(prefix + connector + name)
        if os.path.isdir(full):
          extension = '    ' if i == len(entries)-1 else '│   '
          tree(full, prefix + extension)
        </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Рекурсивный обход удобен для инспекции файловой системы и диагностики. Важно обрабатывать ошибки доступа и избегать зацикливания при наличии символических ссылок. Для больших деревьев полезно лимитировать глубину или использовать итеративный подход с очередью.</p>
      </div>
      <h4>Построчные пояснения к функции tree</h4>
      <ol>
        <li><strong>import os</strong> — модуль для работы с файловой системой;</li>
        <li><strong>entries = sorted(os.listdir(path))</strong> — получаем список файлов/папок и сортируем для предсказуемого вывода;</li>
        <li><strong>for i, name in enumerate(entries):</strong> — итерация с индексом для выбора символа соединителя;</li>
        <li><strong>if os.path.isdir(full): tree(full, prefix + extension)</strong> — рекурсивно заходим в подпапки с корректным префиксом.</li>
      </ol>
    </section>

    <section id="t27" class="ticket">
      <h2>Билет 27 — GET запрос к публичному API и курс ZWL</h2>
      <pre><code>
    import requests

    # Выполняет GET-запрос к публичному API и извлекает курс ZWL из поля rates.
    try:
        resp = requests.get('https://api.exchangerate-api.com/v4/latest/USD', timeout=5)
        resp.raise_for_status()
        data = resp.json()
        print(data.get('rates', {}).get('ZWL'))
    except requests.RequestException as e:
        print('Ошибка запроса:', e)
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>При работе с внешними API важно обрабатывать ошибки, таймауты и отсутствующие поля. В демо-версии мы просто берём поле ZWL из ответа, но в реальном приложении следует добавлять кэширование, retries и мониторинг изменений в структуре API.</p>
      </div>
      <h4>Построчные пояснения к вызову API</h4>
      <ol>
        <li><strong>resp = requests.get(..., timeout=5)</strong> — делаем запрос с таймаутом, чтобы не зависнуть;</li>
        <li><strong>resp.raise_for_status()</strong> — выбрасывает исключение при ошибочном HTTP-коде (4xx/5xx);</li>
        <li><strong>data = resp.json()</strong> — парсим JSON-ответ в питоновский словарь;</li>
        <li><strong>data.get('rates', {}).get('ZWL')</strong> — безопасно извлекаем курс ZWL, даже если ключей нет.</li>
      </ol>
    </section>

    <section id="t28" class="ticket">
      <h2>Билет 28 — Резервное копирование таблицы в другую таблицу с временной меткой</h2>
      <pre><code>
    -- Создаёт снимок таблицы VIPData с меткой времени в названии/поле для сохранения состояния на момент бэкапа.
    CREATE TABLE VIPData_Backup_20251223 AS
    SELECT *, CURRENT_TIMESTAMP AS backup_ts
    FROM VIPData;
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Создание таблицы-дампа сохраняет снимок состояния на конкретную дату. Это простой и быстрый способ бэкапа на уровне таблицы. Для регулярных бэкапов рекомендуется использовать автоматизированные скрипты с ротацией, хранением на отдельном диске/резервном хранилище и проверкой целостности.</p>
      </div>
      <h4>Построчные пояснения к бэкап-запросу</h4>
      <ol>
        <li><strong>CREATE TABLE VIPData_Backup_YYYYMMDD AS</strong> — создаёт новую таблицу на основе результата SELECT;</li>
        <li><strong>SELECT *, CURRENT_TIMESTAMP AS backup_ts FROM VIPData</strong> — копирует все колонки и добавляет метку времени;</li>
        <li><strong>Хранение</strong> — рекомендуется сохранять такие таблицы в отдельной схеме или базе и планировать удаление старых бэкапов.</li>
      </ol>
    </section>

    <section id="t29" class="ticket">
      <h2>Билет 29 — Планирование задачи на 04:00 через день</h2>
      <p>Пример cron-выражения (каждые два дня в 04:00):</p>
      <pre><code>
    -- Cron: запускать ежедневно в 04:00, а внутри скрипта проверять, нужно ли выполнить задачу в этот день.
    0 4 * * * /path/to/script.sh
      </code></pre>

      <div class="speech">
        <strong>Подробная речь перед комиссией (готовая):</strong>
        <p>Cron не поддерживает выражение "через день" напрямую. Практический подход — запускать задачу ежедневно в 04:00 и внутри скрипта проверять условие (например, чётность дня или флаг в базе). Также можно использовать systemd timers или Celery Beat для более гибкого планирования. В ответе подчеркните trade-offs: cron — прост, но менее гибкий; Celery — требует инфраструктуры, но даёт гибкость и надёжность в распределённых системах.</p>
      </div>
      <h4>Построчное пояснение cron-подхода</h4>
      <ol>
        <li><strong>0 4 * * * /path/to/script.sh</strong> — cron expression: запуск ежедневно в 04:00;</li>
        <li><strong>Логика внутри скрипта</strong> — проверка, нужен ли запуск в этот день (например, проверка даты или флага в БД для выполнения «через день»);</li>
        <li><strong>Альтернатива</strong> — systemd timers или Celery Beat для более гибкого расписания и мониторинга состояния задания.</li>
      </ol>
    </section>

    <footer style="margin-top:30px;font-size:13px;color:#54606b">
      Файл сгенерирован автоматически — wereefy. Этот файл предназначен для подготовки; проверьте требования экзаменационной комиссии к оформлению и цитированию.
    </footer>
  </main>
</body>
</html>
